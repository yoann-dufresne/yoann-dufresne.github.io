<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by TEMPLATED
http://templated.co
Released for free under the Creative Commons Attribution License

Name       : Skeleton
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20130902

-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Yoann Dufresne</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="default.css" rel="stylesheet" type="text/css" media="all" />
<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
  <div id="page" class="container">
  	<div id="header">
  		<!-- Picture of me -->
  		<div id="logo">
  			<img src="images/icone.jpg" alt="" />
  			<h1><a href="#">Yoann Dufresne</a></h1>
  			<span>Computer scientist<br/>PhD in bioinformatics</span>
  		</div>
  		<!-- Side menu -->
  		<div id="menu">
  			<ul>
  				<li
          
          ><a href="index.html" accesskey="1" title="">Homepage</a></li>
  				<li
          
            class="current_page_item"
          
          ><a href="research.html" accesskey="2" title="">Research</a></li>
  				<li><a href="https://github.com/yoann-dufresne" accesskey="3" title="">My Github</a></li>
  				<!--li><a href="#" accesskey="4" title="">My projects</a></li-->
  			</ul>
  		</div>
  	</div>
    <div id="main">
      <!-- Pages top -->
      <div id="banner">
  			<img src="images/vanco.png" alt="" class="image-full" />
  		</div>

      <div id="welcome">
        <!--div class="title">
  				<h2>My research interests</h2>
  				<span class="byline"></span>
  			</div-->
        <div class="title">
  <h2>My research interests</h2>
  <span class="byline"></span>
</div>
<h1 id="phd-thesis-algorithmic-for-automatic-annotations-of-non-ribosomal-peptides">PhD thesis: Algorithmic for automatic annotations of Non Ribosomal Peptides</h1>

<p class="image"><img src="images/graphical_abstract.png" alt="s2m_graphical_abstract" /></p>

<h2 id="abstract">Abstract</h2>

<p>The monomeric composition of polymers is powerful for structure comparison and synthetic
biology, among others. However, most of the online molecular resources only provide
atomic structures but not monomeric structures. So, I designed a software called
smiles2monomers (s2m) to infer monomeric structures from chemical ones.</p>

<p>The underlying algorithm is composed of two steps: a search of the monomers using
a subgraph isomorphism algorithm fitted to data and a tiling algorithm to obtain the
best coverage of the polymer by non-overlapping monomers. The search is based on a
Markovian index improving the execution time by 30% compared to the state of art. The
tiling is performed using a greedy algorithm refined by a “branch &amp; cut” algorithm. s2m
had been tested on two different already annotated datasets. The software reconstructed
the manual annotations with an excellent sensibility in a very short time.</p>

<p>Norine database, the reference knowledge base about specific polymers called Non Ribosomal
Peptides (NRP), is developed by the bonsai research group. s2m, executed on the Norine
database, alerted us about wrong manual annotations. So, s2m not only creates new annotations,
but also facilitates the process of annotation curation. The new annotations
generated by the software are currently used for the discovery of new NRP, new activities
and may be used to create completely new and artificial NRP.</p>

<h2 id="related-publications">Related publications</h2>
<p>Y. Dufresne, L. Noé, V. Leclère, M. Pupin, <strong>Smiles2Monomers: a link between
chemical and biological structures for polymers</strong>, J. of Cheminformatics (2016), <a href="https://www.ncbi.nlm.nih.gov/pubmed/26715946">link</a></p>

<p>M. Pupin, Q. Esmaeel, A. Flissi, Y. Dufresne, P. Jacques, V. Leclère, <strong>Norine: a
powerful resource for novel nonribosomal peptide discovery</strong>, Synth. and Sys.
Biotech. (2015), <a href="http://www.sciencedirect.com/science/article/pii/S2405805X15300144">link</a></p>

<p>A. Flissi, Y. Dufresne, J. Michalik, L. Tonon, S. Janot, L. Noé, P. Jacques, V.
Leclère, M. Pupin, <strong>Norine, the knowledgebase dedicated to non-ribosomal
peptides, is now open to crowdsourcing</strong>, Nuc. Acids Res. (2015), <a href="http://nar.oxfordjournals.org/content/44/D1/D1113.short">link</a></p>

<h2 id="links">Links</h2>
<p>Thesis manuscript (in french): <a href="https://yoann-dufresne.github.io/Thesis/manuscrit.pdf">https://yoann-dufresne.github.io/Thesis/manuscrit.pdf</a><br />
Smiles2Monomers: <a href="http://bioinfo.lifl.fr/norine/smiles2monomers.jsp">http://bioinfo.lifl.fr/norine/smiles2monomers.jsp</a><br />
Source code: <a href="https://github.com/yoann-dufresne/Smiles2Monomers">https://github.com/yoann-dufresne/Smiles2Monomers</a></p>

<h1 id="minimal-deterministic-universal-levenshtein-automaton-dula-creation-and-exploitation">Minimal Deterministic Universal Levenshtein Automaton (DULA), creation and exploitation</h1>

<p>All those words in a single sentence ! Don’t be afraid I will explain the whole thing in a very simple way !</p>

<p class="image"><img src="images/dula1.png" alt="dula 1" /></p>

<h2 id="the-levenshtein-automaton">The Levenshtein Automaton</h2>

<p>The Levenshtein distance, also called edit distance, is the minimal number of operations needed to transform a word x into a word y on a given alphabet.
The only modifications allowed are insertion, deletion or substitution of a letter.
For example, the word ABBA is at a distance 2 of AAA (a deletion and a substitution).
We can easily create an automaton <a href="https://en.wikipedia.org/wiki/Levenshtein_automaton">accepting every words with, at most, a distance k</a> of a given word x, for a fixed k.
But this kind of automaton is specific to the word x.
With a simple change of the alphabet, we can dissociate the concept of word recognition from a fixed word.
Instead of looking for the mutations of a letter l of a given word x, we can simply focus on the similarity/dissimilarity of a letter at a given position.
So instead of a given set of letters we can use an alphabet where each symbol represents all the possible similarities/dissimilarities.
For example, instead of saying that AA is at distance 1 of AB by one substitution, AA is at distance 1 of AC, … you can just say that all the words that have 2 letters and the first one in common with AA are at distance one of AA.
The resulting automaton is called the Universal Levenshtein Automaton.</p>

<h2 id="neighborhood-of-a-word">Neighborhood of a word</h2>

<p>When I was a PhD student in Lille, Hélène Touzet, our group leader, was interested in the generation of this automaton.
Specifically, she wanted to know the number of neighbors for a given word at a fixed maximal edit distance <em>k</em>.
The straightforward way to count this neighborhood is to generate all the neighbors, removing the redundant ones.
For instance, the word AA has 7 neighbors at distance 1 on the alphabet <script type="math/tex">\Gamma</script>={A, B} (A, AB, BA, AAA, BAA, ABA, AAB).
But this method is very inefficient. This is really inefficient, because this generation need an exponential time (<script type="math/tex">O(|\Gamma|^{|x|}</script>).
Another way to look at the problem is to focus on the specificity of the possible alignments between a word an its neighbors.
But this method needs to define many different particular cases and leads to an upper bound because of the non unicity of some alignments.</p>

<p>So Hélène took the problem like an automaton problem.
First, she synthesized the work of many people to produce an efficient algorithm to generate the Deterministic Universal Levenshtein Automaton.
Then she used the fact that you can generate a DULA once for each k value and make the product of this automaton with an automaton representing the word of interest to count the neighborhood.
For more details on the algorithms, you can read the research article cited after this text.</p>

<h2 id="my-contributions">My contributions</h2>

<p>I am not a co-author of this article, but I really appreciate the beauty of the method.
That’s why I started to implement the algorithms as a proof of concept.
My idea is to use this code to determine, from a given word, the probabilities of getting a given sequence at distance k by chance compared to the other neighbors at the same edit distance.</p>

<p>For now, I wrote the code that can generate any DULA (if your RAM is large enough).
I used a minimizer on all the automata for k&lt;=7 and the outputs are similar to the inputs.
So, the algorithms seem to generate the minimal automata but we don’t have any proof yet.
All the C++ code is <a href="https://github.com/yoann-dufresne/ula">available on my github</a>.</p>

<p>My next step is to write the code to browse (genre naviguer ?) the product of the automata and output the count of the neighbors.</p>

<h2 id="related-publications-1">Related publications</h2>

<p>H. Touzet, <strong>On the Levenshtein Automaton and the Size of the Neighbourhood of a Word</strong>, conf. LATA 2016,<a href="http://link.springer.com/chapter/10.1007/978-3-319-30000-9_16">link</a><br />
Y. Dufresne, H. Touzet, <strong>The neighbourhood of a string for the Levenshtein distance</strong>, conf. seqbio 2016, <a href="http://www.gdr-bim.cnrs.fr/seqbio2016/wp-content/uploads/2016/11/seqbio2016_paper_11.pdf">abstract</a> <a href="http://www.gdr-bim.cnrs.fr/seqbio2016/wp-content/uploads/2016/11/transparents_touzet.pdf">slides</a></p>

<h2 id="links-1">Links</h2>

<p>ula (DULA generation): <a href="https://github.com/yoann-dufresne/ula">https://github.com/yoann-dufresne/ula</a><br />
wordborhood: <a href="https://github.com/yoann-dufresne/wordborhood">work in progress</a></p>



  		</div>


    </div>
  </div>
</body>
